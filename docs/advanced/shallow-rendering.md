To facilitate writing robust unit tests when using Roact, utilities are provided for shallow rendering and snapshotting components. Shallow rendering involves rendering 1 or more levels deep to assert facts about the rendered elements, allowing components to be tested as units. Snaphotting involves converting these shallow renders to serializable Lua modules for debugging purposes or to verify that components have not changed unexpectedly.

## Shallow Wrapper

When writing tests for Roact components, the `VirtualTree` returned by `Roact.mount` can provide a `ShallowWrapper` object with an interface designed to help make assertions about the expected behavior of a component.

```lua
-- let's assume there is a ComponentToTest that we want to test

local tree = Roact.mount(ComponentToTest)

local shallowWrapper = tree:getShallowWrapper()
```

## Snapshot Testing

A snapshot is a serializable representation of a shallow rendered Roact tree that can be serialized as a complete Lua `ModuleScript`. The snapshot can either be compared with a past snapshot written to `ReplicatedStorage` or returned as a string for debugging purposes.

The goal of a snapshot test is to verify that the shallow render matches the version saved previously. If a snapshot does not match, then the component may have changed unexpectedly. Snapshot testing can be done through the `matchSnapshot` method on the `ShallowWrapper`. The single argument of `matchSnapshot` is the name of the `ModuleScript` in `ReplicatedStorage` to look for.

```lua
shallowWrapper:matchSnapshot("ComponentToTest")
```

Here is a breakdown of how matching is performed:

1. Check if there is an existing snapshot with the given name
2. If no snapshot exists, generate a new one from the `ShallowWrapper` and exit, else continue
3. Load the existing snapshot by calling require on the `ModuleScript`
4. Compare the existing snapshot with the one generated by the `ShallowWrapper`
5. If the snapshots match, exit, else save the new `ModuleScript` (useful for comparison) and throw an error

!!! Note
	Currently, the `ModuleScript` for new snapshots will be stored in a `StringValue`. The permission level where the test are ran does not make it possible to create a `ModuleScript` and assign its `Source` property. Tools like Roact's SnapshotsPlugin can copy the `StringValue` from Run mode to a `ModuleScript` in Edit mode.

!!! Note
	The scripts generated by `matchSnapshot` are not guaranteed to pass [luacheck](https://github.com/mpeterv/luacheck/) due to the potential for unused variables, so be careful not to run `luacheck` on them.
---

### Workflow Example

For a concrete example, suppose the following component `ComponentToTest`.

```lua
local function ComponentToTest(props)
	return Roact.createElement("TextLabel", {
		Text = "foo",
	})
end
```

A snapshot test could be written this way:

```lua
it("should match the snapshot", function()
	local element = Roact.createElement(ComponentToTest)
	local tree = Roact.mount(element)
	local shallowWrapper = tree:getShallowWrapper()

	shallowWrapper:matchSnapshot("ComponentToTest")
end)
```

After the first run, the test will have created a new script under `RoactSnapshots` in `ReplicatedStorage` called `ComponentToTest` that contains the following Lua code:

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Host,
      className = "TextLabel",
    },
    props = {
      Text = "foo",
    },
    children = {},
  }
end
```

Since these tests require the previous snapshots to compare with the current generated one, snapshots should be saved (if using Studio) or committed to version control (if using file system development).

Suppose now `ComponentToTest` is updated as follows:

```lua
local function ComponentToTest(props)
	return Roact.createElement("TextLabel", {
		Text = "bar",
	})
end
```

When the test is run again, it will fail, noting that the snapshots did not match. There will be a new script under `RoactSnapshots` called `ComponentToTest.NEW` that shows the new version of the snapshot.

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Host,
      className = "TextLabel",
    },
    props = {
      Text = "bar",
    },
    children = {},
  }
end
```

Only the `Text` prop value changed, from *foo* to *bar*. Since these changes are expected from the modification made to the component, we can delete the old snapshot and remove the `.NEW` from the newest one. If the tests are run again, they will once again pass.

Updated snapshots should be saved / committed along with the component changes to make it clear why the snapshot is being changed.

Most snapshots will be more complex than this example and act as a powerful line of defense against unexpected changes to components.

---

### Where They Are Good

#### Regression

Snapshot tests really shine when comes the time to test for regression.

#### Carefully Reviewed

Changes made to a snapshot file needs to be reviewed carefully as if it was hand written code. A reviewer needs to be able to catch any unexpected changes to a component. Any source control software should provide some way to see a diff of the changes that are going to be submitted. If a snapshot diff shows a difference in the color property for a change that is supposed to update  sizing, the reviewer should verify that the change is intended.

---

### Where They Are Bad

#### Large Snapshots

If a snapshot is created from a top level component with a ShallowWrapper that renders many levels deep, it can produce a large snapshot file with potentially hundreds of lines. The larger the snapshot, the more likely it is to fail due to a reason unrelated to the component being tested.

Large snapshots also become an inconvenience and may not be reviewed correctly due to their size or frequency of needing an update, or both.

To avoid this situation, it is important that each snapshot is kept as simple and as small as possible. That is why the `ShallowWrapper` is deeply linked with snapshot generation and defaults to rendering only 1 level deep. Render more deeply only as needed to exercise the component being tested.

---

### Managing Snapshots

When the tests are executed in Run mode (after Run is pressed), snapshots are serialized and saved as `StringValue` objects inside of `ReplicatedStorage.RoactSnapshots`. Pressing Stop to go back to Edit mode will delete any newly created snapshots values. Preserving the serialized snapshots and saving them as module scripts is necessary to ensure that there are snapshots to match with during future test runs. The method of preserving them varies based on the development environment being used.

#### Roblox Studio
 If using Roblox Studio for development, install the `RoactSnapshots` plugin, which will preserve the `StringValue` objects and save them as `ModuleScript` objects upon returning to Edit mode.

---

#### File System

If using a tool like `rojo` to sync files to Roblox Studio, a tool like `run-in-roblox` can help write the module scripts back to the file system.

[`run-in-roblox`](https://github.com/LPGhatguy/run-in-roblox/) is a [`Rust`](https://www.rust-lang.org/) command line tool that runs Roblox Studio and sends content from the output to the shell window. Using this tool, a script can be written to open a place file and run it with a specific test runner that can print out the new snapshots in a special format. Then, the output can be parsed to find the new snapshots and write them to files.

Here are examples of this kind of script written in Lua ([link](../scripts/sync-snapshots-with-lua.md)) and in python ([link](../scripts/sync-snapshots-with-python.md)) (compatible with version 2 and 3). These example scripts assume that the `rojo` and `run-in-roblox` commands are available. They build a place from a `rojo` configuration file, run a specific script inside studio, print the serialized snapshots, parse them from the output, and write them to the file system.

---

### Wrapped Components

Sometimes during testing, components need to be wrapped into other components that provides some of their props. When comes the time to make a snapshot of that components, it's preferable to snapshot it without the wrapping component. The main reason for this is to avoid snapshot test failure when there is a change in the wrapping component that does not affect the wrapped component.

In the case where the component is wrapped in a host component (a component that render a Roblox instance), use ShallowWrapper's [`find`](/api-reference/#find) or [`findUnique`](/api-reference/#findunique) methods to get to your child component. Otherwise, increase the depth option to get deep enough so that the parent component is consumed.

!!! Note
	When making snapshot tests, depth is generally used more often than `find` or `findUnique`. Components may have multiple layer of elements nested: that will require adjusting the depth to render at least until the last element. The ShallowWrapper's methods that access its children are more used when working on generic components. These generic components may be a bit harder or tricky to test because they depend on other concrete components that get wrappred into them.

---

#### Example With *find* Method

Let's suppose `InFrame` is a component that accept a render prop. The render function is used to render an element inside a black background frame. The component will pass props that need to be set on the child element.

```lua
local function InFrame(props)
	return Roact.createElement("Frame", {
		BackgroundColor3 = Color3.new(0, 0, 0),
	}, {
		Content = props.render({
			BackgroundTransparency = 1,
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),
		}),
	})
end
```

Another component called `CoolComponent` is using this generic component to render a TextLabel inside a frame.

```lua
local function CoolComponent()
	return Roact.createElement(InFrame, {
		render = function(props)
			props.Text = "Hello"
			return Roact.createElement("TextLabel", props)
		end,
	})
end
```

When writting a snapshot test for `CoolComponent`, it is better to avoid having details about the `InFrame` component. The important things are to be aware of what could change in the relation between `InFrame` and `CoolComponent`. Any changes made to `InFrame` that does not impact `CoolComponent` should not break the snapshot.

The first version of the test may look like the following snippet:

```lua
local element = Roact.createElement(CoolComponent)

local tree = Roact.mount(element)

local wrapper = tree:getShallowWrapper()

wrapper:matchSnapshot("CoolComponent")
```

That will produce the following snapshot:

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Function,
    },
    props = {
      render = Markers.AnonymousFunction,
    },
    children = {
      {
        type = {
          kind = ElementKind.Host,
          className = "Frame",
        },
        hostKey = "RoactTree",
        props = {
          BackgroundColor3 = Color3.new(0, 0, 0),
        },
        children = {},
      },
    },
  }
end
```

As you can see, this snapshot contains the `render` prop of `InFrame`. The information about the TextLabel is also absent, because the ShallowWrapper has a depth of one by default and the TextLabel is getting wrapped into a Frame. In order to get the TextLabel to show up in the snapshot, the depth is going to be bumped to 2. The updated test will look like:

```lua
local element = Roact.createElement(CoolComponent)

local tree = Roact.mount(element)

local wrapper = tree:getShallowWrapper({
	depth = 2,
})

wrapper:matchSnapshot("CoolComponent")
```

And the updated snapshot is going to contain data about the TextLabel.

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Host,
      className = "Frame",
    },
    props = {
      BackgroundColor3 = Color3.new(0, 0, 0),
    },
    children = {
      {
        type = {
          kind = ElementKind.Host,
          className = "TextLabel",
        },
        hostKey = "Content",
        props = {
          BackgroundTransparency = 1,
          Position = UDim2.new(0, 0, 0, 0),
          Size = UDim2.new(1, 0, 1, 0),
          Text = "Hello",
        },
        children = {},
      },
    },
  }
end
```

Now, to remove the details about the `InFrame` component, the snapshot is not going to be generated from the top level ShallowWrapper, but instead from the child inside of it.

```lua
local element = Roact.createElement(CoolComponent)

local tree = Roact.mount(element)

local wrapper = tree:getShallowWrapper({
	depth = 2,
})

local coolWrapper = wrapper:findUnique()

coolWrapper:matchSnapshot("CoolComponent")
```

Since the top level Frame contains only one child, we can use `findUnique` instead of `find`. This will produce the following snapshot:

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Host,
      className = "TextLabel",
    },
    props = {
      BackgroundTransparency = 1,
      Position = UDim2.new(0, 0, 0, 0),
      Size = UDim2.new(1, 0, 1, 0),
      Text = "Hello",
    },
    children = {},
  }
end
```

The good thing now about this snapshot is that it will only fail when the contract between `InFrame` and `CoolComponent` changes.

---

#### Example With Depth

Let's say `CoolComponent` is using another component that wraps it with a render prop. The consumer is going to pass a table containing data about the style. For the purpose of this example, the props are minimal but it still shows the idea.

```lua
local function CoolComponent(props)
	return Roact.createElement(StyleConsumer, {
		render = function(style)
			return Roact.createElement("Frame", {
				BackgroundColor3 = style.MainColor,
			})
		end,
	})
end
```

Usually, this complexity is hidden behind a simple function like the following snippet.

```lua
local function CoolComponent(props)
	return withStyle(function(style)
		return Roact.createElement("Frame", {
			BackgroundColor3 = style.MainColor,
		}, {
			Label = Roact.createElement("TextLabel"),
		})
	end)
end
```

We can write a test that is going to snapshot the `CoolComponent`.

```lua
local element = Roact.createElement(CoolComponent)

local tree = Roact.mount(element)
local wrapper = tree:getShallowWrapper()

wrapper:matchSnapshot("CoolSnapshot")
```

And the generated snapshot looks like this:

```lua
{
  type = {
    kind = ElementKind.Function,
  },
  props = {
    render = Markers.AnonymousFunction, -- the render prop from the StyleConsumer
  },
  children = {
    {
      type = {
        kind = ElementKind.Host,
        className = "Frame",
      },
      hostKey = "RoactTree",
      props = {
        BackgroundColor3 = Color3.new(1, 1, 1), -- style.MainColor
      },
      children = {},
    },
  },
}
```

When writing the test to snapshot `CoolComponent`, you will want to use to avoid having details of the `StyleConsumer`. The reason is that if `StyleConsumer` changes, the test may fail without really changing the important part of our snapshot, which is the information about `CoolComponent`.

Also, notice that there is no information about the `TextLabel`, because the method `getShallowWrapper` only returns a shallow version of the mounted tree. If we want to have access to the next depth of the tree, we need to pass the option `depth = 2`.

```lua
local element = Roact.createElement(CoolComponent)

local tree = Roact.mount(element)
local wrapper = tree:getShallowWrapper({
	depth = 2,
})

wrapper:matchSnapshot("CoolSnapshot")
```

We get the following new generated snapshot.

```lua
{
  type = {
    kind = ElementKind.Host,
    className = "Frame",
  },
  props = {
    BackgroundColor3 = Color3.new(1, 1, 1),
  },
  children = {
    {
      type = {
        kind = ElementKind.Host,
        className = "TextLabel",
      },
      hostKey = "Label",
      props = {},
      children = {},
    },
  },
}
```

As you can see, the `StyleConsumer` disappeared. The wrapper returned by `getShallowWrapper` does not directly wrap the element tree. Instead, it wraps elements that are rendered as Roblox instances as deep as it can. Since, the test now allow the wrapper to go deeper, it will get rid of the `StyleConsumer` because it does not render to a Roblox instance.
