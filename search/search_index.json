{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Roact is a declarative Lua UI library similar to Facebook's React . It exposes a very similar API and implements nearly identical semantics. This documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect, open an issue on GitHub ! Info This documentation assumes some familiarity with Lua. If you're new to Lua, Programming in Lua by Roberto Ierusalimschy is a good introduction, and the first edition (for Lua 5.0) is available online for free.","title":"Home"},{"location":"api-reference/","text":"Methods \u00b6 Roact.createElement \u00b6 Roact.createElement(component, [props, [children]]) -> RoactElement Creates a new Roact element representing the given component . Elements are lightweight descriptions about what a Roblox Instance should look like, like a blueprint! The children argument is shorthand for adding a Roact.Children key to props . It should be specified as a dictionary of names to elements. component can be a string, a function, or a table created by Component:extend . Caution Make sure not to modify props or children after they're passed into createElement ! Roact.createFragment \u00b6 Added in Roact 1.0.0 Roact.createFragment(elements) -> RoactFragment Creates a new Roact fragment with the provided table of elements. Fragments allow grouping of elements without the need for intermediate containing objects like Frame s. Caution Make sure not to modify elements after they're passed into createFragment ! Roact.mount \u00b6 Roact.mount(element, [parent, [key]]) -> RoactTree Info Roact.mount is also available via the deprecated alias Roact.reify . It will be removed in a future release. Creates a Roblox Instance given a Roact element, and optionally a parent to put it in, and a key to use as the instance's Name . The result is a RoactTree , which is an opaque handle that represents a tree of components owned by Roact. You can pass this to APIs like Roact.unmount . It'll also be used for future debugging APIs. Roact.update \u00b6 Roact.update(tree, element) -> RoactTree Info Roact.update is also available via the deprecated alias Roact.reconcile . It will be removed in a future release. Updates an existing instance handle with a new element, returning a new handle. This can be used to update a UI created with Roact.mount by passing in a new element with new props. update can be used to change the props of a component instance created with mount and is useful for putting Roact content into non-Roact applications. As of Roact 1.0, the returned RoactTree object will always be the same value as the one passed in. Roact.unmount \u00b6 Roact.unmount(tree) -> void Info Roact.unmount is also available via the deprecated alias Roact.teardown . It will be removed in a future release. Destroys the given RoactTree and all of its descendants. Does not operate on a Roblox Instance -- this must be given a handle that was returned by Roact.mount . Roact.oneChild \u00b6 Roact.oneChild(children) -> RoactElement | nil Given a dictionary of children, returns a single child element. If children contains more than one child, oneChild function will throw an error. This is intended to denote an error when using the component using oneChild . If children is nil or contains no children, oneChild will return nil . Roact.createBinding \u00b6 Added in Roact 1.0.0 Roact.createBinding(initialValue) -> Binding, updateFunction where updateFunction: (newValue) -> () The first value returned is a Binding object, which will typically be passed as a prop to a Roact host component. The second is a function that can be called with a new value to update the binding. A Binding has the following API: getValue \u00b6 Binding:getValue() -> value Returns the internal value of the binding. This is helpful when updating a binding relative to its current value. Warning Using getValue inside a component's render method is dangerous! Using the unwrapped value directly won't allow Roact to subscribe to a binding's updates. To guarantee that a bound value will update, use the binding itself for your prop value. map \u00b6 Binding:map(mappingFunction) -> Binding where mappingFunction: (value) -> mappedValue Returns a new binding that maps the existing binding's value to something else. For example, map can be used to transform an animation progress value like 0.4 into a property that can be consumed by a Roblox Instance like UDim2.new(0.4, 0, 1, 0) . Roact.joinBindings \u00b6 Added in Roact 1.1.0 Roact.joinBindings(bindings) -> Binding where bindings: { [any]: Binding } Combines multiple bindings into a single binding. The new binding's value will have the same keys as the input table of bindings. joinBindings is usually used alongside Binding:map : local function Flex () local aSize , setASize = Roact . createBinding ( Vector2 . new ()) local bSize , setBSize = Roact . createBinding ( Vector2 . new ()) return Roact . createElement ( \"Frame\" , { Size = Roact . joinBindings ({ aSize , bSize }): map ( function ( sizes ) local sum = Vector2 . new () for _ , size in ipairs ( sizes ) do sum = sum + size end return UDim2 . new ( 0 , sum . X , 0 , sum . Y ) end ), }, { A = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 1 , 0 , 0 , 30 ), [ Roact . Change . AbsoluteSize ] = function ( instance ) setASize ( instance . Size ) end , }), B = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 1 , 0 , 0 , 30 ), Position = aSize : map ( function ( size ) return UDim2 . new ( 0 , 0 , 0 , size . Y ) end ), [ Roact . Change . AbsoluteSize ] = function ( instance ) setBSize ( instance . Size ) end , }), }) end Roact.createRef \u00b6 Roact.createRef() -> Ref Creates a new reference object that can be used with Roact.Ref . Roact.forwardRef \u00b6 Added in Roact 1.4.0 Roact.forwardRef(render: (props: table, ref: Ref) -> RoactElement) -> RoactComponent Creates a new component given a render function that accepts both props and a ref, allowing a ref to be forwarded to an underlying host component via Roact.Ref . Roact.createContext \u00b6 Added in Roact 1.3.0 Roact.createContext(defaultValue: any) -> RoactContext type RoactContext = { Provider: Component, Consumer: Component, [private fields] } Creates a new context provider and consumer. For a usage guide, see Advanced Concepts: Context . defaultValue is given to consumers if they have no Provider ancestors. It is up to users of Roact's context API to turn this case into an error if it is an invalid state. Provider and Consumer are both Roact components. Provider \u00b6 Provider accepts the following props: value : The value to put into the tree for this context value. If the Provider is updated with a new value , any matching Consumer components will be re-rendered with the new value. [Children] : Any number of children to render underneath this provider. Descendants of this component can receive the provided context value by using Consumer . Consumer \u00b6 Consumer accepts just one prop: render(value) -> RoactElement | nil : A function that will be invoked to render any children. render will be called every time Consumer is rendered. Roact.setGlobalConfig \u00b6 Roact.setGlobalConfig(configValues: Dictionary<string, bool>) -> void The entry point for configuring Roact. Roact currently applies this to everything using this instance of Roact, so be careful using this with a project that has multiple consumers of Roact. Once config values are set, they will apply from then on. This is primarily useful when developing as it can enable features that validate your code more strictly. Most of the settings here incur a performance cost and should typically be disabled in production environments. Call this method once at the root of your project (before mounting any Roact elements): Roact . setGlobalConfig ({ typeChecks = true , propValidation = true , }) The following are the valid config keys that can be used, and what they do. typeChecks \u00b6 Enables type checks for Roact's public interface. This includes some of the following: Check that the props and children arguments to Roact.createElement are both tables or nil Check that setState is passing self as the first argument (it should be called like self:setState(...) ) Confirm the Roact.mount 's first argument is a Roact element And much more! internalTypeChecks \u00b6 Enables type checks for internal functionality of Roact. This is typically only useful when debugging Roact itself. It will run similar type checks to those mentioned above, but only the private portion of the API. elementTracing \u00b6 When enabled, Roact will capture a stack trace at the site of each element creation and hold onto it, using it to provide additional details on certain kinds of errors. If you get an error that says \" \", try enabling this config value to help with debugging. Enabling elementTracing also allows the use of the getElementTraceback method on Component, which can also be helpful for debugging. propValidation \u00b6 Enables validation of props via the validateProps method on components. With this flag enabled, any validation written by component authors in a component's validateProps method will be run on every prop change. This is helpful during development for making sure components are being used correctly. Constants \u00b6 Roact.Children \u00b6 This is the key that Roact uses internally to store the children that are attached to a Roact element. If you're writing a new function component or stateful component that renders children like a host component, you can access Roact.Children in your props table. Roact.Ref \u00b6 Use Roact.Ref as a key into the props of a host element to receive a handle to the underlying Roblox Instance. Assign this key to a ref created with createRef : local ExampleComponent = Roact . Component : extend ( \"ExampleComponent\" ) function ExampleComponent : init () -- Create a ref. self . ref = Roact . createRef () end function ExampleComponent : render () return Roact . createElement ( \"Frame\" , { -- Use the ref to point to this rendered instance. [ Roact . Ref ] = self . ref , }) end function ExampleComponent : didMount () -- Refs are a kind of binding, so we can access the Roblox Instance using getValue. print ( \"Roblox Instance\" , self . ref : getValue ()) end Info Ref objects have a deprecated field called current that is always equal to the result of getValue . Assigning to the current field is not allowed. The field will be removed in a future release. Alternatively, you can assign it to a function instead: Roact . createElement ( \"Frame\" , { -- The provided function will be called whenever the rendered instance changes. [ Roact . Ref ] = function ( rbx ) print ( \"Roblox Instance\" , rbx ) end , }) Warning When Roact.Ref is given a function, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact updates that prop! Warning When Roact.Ref is given a function, it will be called with nil when the component instance is destroyed! See the refs guide for more details. Roact.Event \u00b6 Index into Roact.Event to receive a key that can be used to connect to events when creating host elements: Roact . createElement ( \"ImageButton\" , { [ Roact . Event . MouseButton1Click ] = function ( rbx , x , y ) print ( rbx , \"clicked at position\" , x , y ) end , }) Info Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event. Warning When connecting to the Changed event, be careful not to call setState or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown! See the events guide for more details. Roact.Change \u00b6 Index into Roact.Change to receive a key that can be used to connect to GetPropertyChangedSignal events. It's similar to Roact.Event : Roact . createElement ( \"ScrollingFrame\" , { [ Roact . Change . CanvasPosition ] = function ( rbx ) print ( \"ScrollingFrame scrolled to\" , rbx . CanvasPosition ) end , }) Warning Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown! Roact.None \u00b6 Roact.None is a special value that can be used to clear elements from your component state when calling setState or returning from getDerivedStateFromProps . In Lua tables, removing a field from state is not possible by setting its value to nil because nil values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to Roact.None when calling setState , which will ensure that the resulting state no longer contains it: function MyComponent : didMount () self : setState ({ fieldToRemove = Roact . None }) end Component Types \u00b6 Roact.Component \u00b6 The base component instance that can be extended to make stateful components. Call Roact.Component:extend(\"ComponentName\") to make a new stateful component with a given name. Roact.PureComponent \u00b6 An extension of Roact.Component that only re-renders if its props or state change. PureComponent implements the shouldUpdate lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux. PureComponent is not always faster, but can often result in significant performance improvements when used correctly. Roact.Portal \u00b6 A component that represents a portal to a Roblox Instance. Portals are created using Roact.createElement . Any children of a portal are put inside the Roblox Instance specified by the required target prop. That Roblox Instance should not be one created by Roact. Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once. See the Portals guide for a small tutorial and more details about portals. Component API \u00b6 defaultProps \u00b6 static defaultProps: Dictionary<any, any> If defaultProps is defined on a stateful component, any props that aren't specified when a component is created will be taken from there. init \u00b6 init(initialProps) -> void init is called exactly once when a new instance of a component is created. It can be used to set up the initial state , as well as any non- render related values directly on the component. Use setState inside of init to set up your initial component state: function MyComponent : init () self : setState ({ position = 0 , velocity = 10 }) end In older versions of Roact, setState was disallowed in init , and you would instead assign to state directly. It's simpler to use setState , but assigning directly to state is still acceptable inside init : function MyComponent : init () self . state = { position = 0 , velocity = 10 } end render \u00b6 render() -> Element | nil render describes what a component should display at the current instant in time. Info Roact assumes that render act likes a pure function: the result of render must depend only on props and state , and it must not have side-effects. function MyComponent : render () -- This is okay: return Roact . createElement ( \"TextLabel\" , { Text = self . props . text , Position = self . state . position }) -- Ack! Depending on values outside props/state is not allowed! return Roact . createElement ( \"TextLabel\" , { Text = self . someText , Position = getMousePosition (), }) end render must be defined for all components. The default implementation of render throws an error; if your component does not render anything, define a render function that returns nil explicitly. This helps make sure that you don't forget to define render ! function MyComponent : render () return nil end setState \u00b6 setState(stateUpdater | stateChange) -> void setState requests an update to the component's state. Roact may schedule this update for a later time or resolve it immediately. If a function is passed to setState , that function will be called with the current state and props as arguments: function MyComponent : didMount () self : setState ( function ( prevState , props ) return { counter = prevState . counter + 1 } end ) end If this function returns nil , Roact will not schedule a re-render and no state will be updated. If a table is passed to setState , the values in that table will be merged onto the existing state: function MyComponent : didMount () self : setState ({ foo = \"bar\" }) end Setting a field in the state to Roact.None will clear it from the state. This is the only way to remove a field from a component's state! Warning setState can be called from anywhere except : Lifecycle hooks: willUnmount , willUpdate Pure functions: render , shouldUpdate Calling setState inside of init has special behavior. The result of setState will be used to determine initial state, and no additional updates will be scheduled. Roact may support calling setState in currently-disallowed places in the future. Warning setState does not always resolve synchronously! Roact may batch and reschedule state updates in order to reduce the number of total renders. When depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur! This behavior will be similar to the future behavior of React 17. See: RFClarification: why is setState asynchronous? Does React keep the order for state updates? shouldUpdate \u00b6 shouldUpdate(nextProps, nextState) -> bool shouldUpdate provides a way to override Roact's rerendering heuristics. By default, components are re-rendered any time a parent component updates, or when state is updated via setState . PureComponent implements shouldUpdate to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, all components may implement this check by default. validateProps \u00b6 Added in Roact 1.0.0 static validateProps(props) -> (false, message: string) | true validateProps is an optional method that can be implemented for a component. It provides a mechanism for verifying inputs passed into the component. Every time props are updated, validateProps will be called with the new props before proceeding to shouldUpdate or init . It should return the same parameters that assert expects: a boolean, true if the props passed validation, false if they did not, plus a message explaining why they failed. If the first return value is true, the second value is ignored. For performance reasons, property validation is disabled by default. To use this feature, enable propValidation via setGlobalConfig : Roact.setGlobalConfig({ propValidation = true }) See setGlobalConfig for more details. Note validateProps is a static lifecycle method. It does not have access to self , and must be a pure function. Warning Depending on the implementation, validateProps can impact performance. Recommended practice is to enable prop validation during development and leave it off in production environments. getElementTraceback \u00b6 getElementTraceback() -> string | nil getElementTraceback gets the stack trace that the component was created in. This allows you to report error messages accurately. Lifecycle Methods \u00b6 In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process. didMount \u00b6 didMount() -> void didMount is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting. didMount is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy. willUnmount \u00b6 willUnmount() -> void willUnmount is fired right before Roact begins unmounting a component instance's children. willUnmount acts like a component's destructor, and is a good place to disconnect any manually-connected events. willUpdate \u00b6 willUpdate(nextProps, nextState) -> void willUpdate is fired after an update is started but before a component's state and props are updated. didUpdate \u00b6 didUpdate(previousProps, previousState) -> void didUpdate is fired after at the end of an update. At this point, Roact has updated the properties of any Roblox Instances and the component instance's props and state are up to date. didUpdate is a good place to send network requests or dispatch Rodux actions, but make sure to compare self.props and self.state with previousProps and previousState to avoid triggering too many updates. getDerivedStateFromProps \u00b6 static getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice Used to recalculate any state that depends on being synchronized with props . Generally, you should use didUpdate to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead. getDerivedStateFromProps should return a table that contains the part of the state that should be updated. function MyComponent . getDerivedStateFromProps ( nextProps , lastState ) return { someValue = nextProps . someValue } end As with setState , you can set use the constant Roact.None to remove a field from the state. Note getDerivedStateFromProps is a static lifecycle method. It does not have access to self , and must be a pure function. Caution getDerivedStateFromProps runs before shouldUpdate and any non-nil return will cause the state table to no longer be shallow-equal. This means that a PureComponent will rerender even if nothing actually changed. Similarly, any component implementing both getDerivedStateFromProps and shouldUpdate needs to do so in a way that takes this in to account.","title":"API Reference"},{"location":"api-reference/#methods","text":"","title":"Methods"},{"location":"api-reference/#roactcreateelement","text":"Roact.createElement(component, [props, [children]]) -> RoactElement Creates a new Roact element representing the given component . Elements are lightweight descriptions about what a Roblox Instance should look like, like a blueprint! The children argument is shorthand for adding a Roact.Children key to props . It should be specified as a dictionary of names to elements. component can be a string, a function, or a table created by Component:extend . Caution Make sure not to modify props or children after they're passed into createElement !","title":"Roact.createElement"},{"location":"api-reference/#roactcreatefragment","text":"Added in Roact 1.0.0 Roact.createFragment(elements) -> RoactFragment Creates a new Roact fragment with the provided table of elements. Fragments allow grouping of elements without the need for intermediate containing objects like Frame s. Caution Make sure not to modify elements after they're passed into createFragment !","title":"Roact.createFragment"},{"location":"api-reference/#roactmount","text":"Roact.mount(element, [parent, [key]]) -> RoactTree Info Roact.mount is also available via the deprecated alias Roact.reify . It will be removed in a future release. Creates a Roblox Instance given a Roact element, and optionally a parent to put it in, and a key to use as the instance's Name . The result is a RoactTree , which is an opaque handle that represents a tree of components owned by Roact. You can pass this to APIs like Roact.unmount . It'll also be used for future debugging APIs.","title":"Roact.mount"},{"location":"api-reference/#roactupdate","text":"Roact.update(tree, element) -> RoactTree Info Roact.update is also available via the deprecated alias Roact.reconcile . It will be removed in a future release. Updates an existing instance handle with a new element, returning a new handle. This can be used to update a UI created with Roact.mount by passing in a new element with new props. update can be used to change the props of a component instance created with mount and is useful for putting Roact content into non-Roact applications. As of Roact 1.0, the returned RoactTree object will always be the same value as the one passed in.","title":"Roact.update"},{"location":"api-reference/#roactunmount","text":"Roact.unmount(tree) -> void Info Roact.unmount is also available via the deprecated alias Roact.teardown . It will be removed in a future release. Destroys the given RoactTree and all of its descendants. Does not operate on a Roblox Instance -- this must be given a handle that was returned by Roact.mount .","title":"Roact.unmount"},{"location":"api-reference/#roactonechild","text":"Roact.oneChild(children) -> RoactElement | nil Given a dictionary of children, returns a single child element. If children contains more than one child, oneChild function will throw an error. This is intended to denote an error when using the component using oneChild . If children is nil or contains no children, oneChild will return nil .","title":"Roact.oneChild"},{"location":"api-reference/#roactcreatebinding","text":"Added in Roact 1.0.0 Roact.createBinding(initialValue) -> Binding, updateFunction where updateFunction: (newValue) -> () The first value returned is a Binding object, which will typically be passed as a prop to a Roact host component. The second is a function that can be called with a new value to update the binding. A Binding has the following API:","title":"Roact.createBinding"},{"location":"api-reference/#getvalue","text":"Binding:getValue() -> value Returns the internal value of the binding. This is helpful when updating a binding relative to its current value. Warning Using getValue inside a component's render method is dangerous! Using the unwrapped value directly won't allow Roact to subscribe to a binding's updates. To guarantee that a bound value will update, use the binding itself for your prop value.","title":"getValue"},{"location":"api-reference/#map","text":"Binding:map(mappingFunction) -> Binding where mappingFunction: (value) -> mappedValue Returns a new binding that maps the existing binding's value to something else. For example, map can be used to transform an animation progress value like 0.4 into a property that can be consumed by a Roblox Instance like UDim2.new(0.4, 0, 1, 0) .","title":"map"},{"location":"api-reference/#roactjoinbindings","text":"Added in Roact 1.1.0 Roact.joinBindings(bindings) -> Binding where bindings: { [any]: Binding } Combines multiple bindings into a single binding. The new binding's value will have the same keys as the input table of bindings. joinBindings is usually used alongside Binding:map : local function Flex () local aSize , setASize = Roact . createBinding ( Vector2 . new ()) local bSize , setBSize = Roact . createBinding ( Vector2 . new ()) return Roact . createElement ( \"Frame\" , { Size = Roact . joinBindings ({ aSize , bSize }): map ( function ( sizes ) local sum = Vector2 . new () for _ , size in ipairs ( sizes ) do sum = sum + size end return UDim2 . new ( 0 , sum . X , 0 , sum . Y ) end ), }, { A = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 1 , 0 , 0 , 30 ), [ Roact . Change . AbsoluteSize ] = function ( instance ) setASize ( instance . Size ) end , }), B = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 1 , 0 , 0 , 30 ), Position = aSize : map ( function ( size ) return UDim2 . new ( 0 , 0 , 0 , size . Y ) end ), [ Roact . Change . AbsoluteSize ] = function ( instance ) setBSize ( instance . Size ) end , }), }) end","title":"Roact.joinBindings"},{"location":"api-reference/#roactcreateref","text":"Roact.createRef() -> Ref Creates a new reference object that can be used with Roact.Ref .","title":"Roact.createRef"},{"location":"api-reference/#roactforwardref","text":"Added in Roact 1.4.0 Roact.forwardRef(render: (props: table, ref: Ref) -> RoactElement) -> RoactComponent Creates a new component given a render function that accepts both props and a ref, allowing a ref to be forwarded to an underlying host component via Roact.Ref .","title":"Roact.forwardRef"},{"location":"api-reference/#roactcreatecontext","text":"Added in Roact 1.3.0 Roact.createContext(defaultValue: any) -> RoactContext type RoactContext = { Provider: Component, Consumer: Component, [private fields] } Creates a new context provider and consumer. For a usage guide, see Advanced Concepts: Context . defaultValue is given to consumers if they have no Provider ancestors. It is up to users of Roact's context API to turn this case into an error if it is an invalid state. Provider and Consumer are both Roact components.","title":"Roact.createContext"},{"location":"api-reference/#provider","text":"Provider accepts the following props: value : The value to put into the tree for this context value. If the Provider is updated with a new value , any matching Consumer components will be re-rendered with the new value. [Children] : Any number of children to render underneath this provider. Descendants of this component can receive the provided context value by using Consumer .","title":"Provider"},{"location":"api-reference/#consumer","text":"Consumer accepts just one prop: render(value) -> RoactElement | nil : A function that will be invoked to render any children. render will be called every time Consumer is rendered.","title":"Consumer"},{"location":"api-reference/#roactsetglobalconfig","text":"Roact.setGlobalConfig(configValues: Dictionary<string, bool>) -> void The entry point for configuring Roact. Roact currently applies this to everything using this instance of Roact, so be careful using this with a project that has multiple consumers of Roact. Once config values are set, they will apply from then on. This is primarily useful when developing as it can enable features that validate your code more strictly. Most of the settings here incur a performance cost and should typically be disabled in production environments. Call this method once at the root of your project (before mounting any Roact elements): Roact . setGlobalConfig ({ typeChecks = true , propValidation = true , }) The following are the valid config keys that can be used, and what they do.","title":"Roact.setGlobalConfig"},{"location":"api-reference/#typechecks","text":"Enables type checks for Roact's public interface. This includes some of the following: Check that the props and children arguments to Roact.createElement are both tables or nil Check that setState is passing self as the first argument (it should be called like self:setState(...) ) Confirm the Roact.mount 's first argument is a Roact element And much more!","title":"typeChecks"},{"location":"api-reference/#internaltypechecks","text":"Enables type checks for internal functionality of Roact. This is typically only useful when debugging Roact itself. It will run similar type checks to those mentioned above, but only the private portion of the API.","title":"internalTypeChecks"},{"location":"api-reference/#elementtracing","text":"When enabled, Roact will capture a stack trace at the site of each element creation and hold onto it, using it to provide additional details on certain kinds of errors. If you get an error that says \" \", try enabling this config value to help with debugging. Enabling elementTracing also allows the use of the getElementTraceback method on Component, which can also be helpful for debugging.","title":"elementTracing"},{"location":"api-reference/#propvalidation","text":"Enables validation of props via the validateProps method on components. With this flag enabled, any validation written by component authors in a component's validateProps method will be run on every prop change. This is helpful during development for making sure components are being used correctly.","title":"propValidation"},{"location":"api-reference/#constants","text":"","title":"Constants"},{"location":"api-reference/#roactchildren","text":"This is the key that Roact uses internally to store the children that are attached to a Roact element. If you're writing a new function component or stateful component that renders children like a host component, you can access Roact.Children in your props table.","title":"Roact.Children"},{"location":"api-reference/#roactref","text":"Use Roact.Ref as a key into the props of a host element to receive a handle to the underlying Roblox Instance. Assign this key to a ref created with createRef : local ExampleComponent = Roact . Component : extend ( \"ExampleComponent\" ) function ExampleComponent : init () -- Create a ref. self . ref = Roact . createRef () end function ExampleComponent : render () return Roact . createElement ( \"Frame\" , { -- Use the ref to point to this rendered instance. [ Roact . Ref ] = self . ref , }) end function ExampleComponent : didMount () -- Refs are a kind of binding, so we can access the Roblox Instance using getValue. print ( \"Roblox Instance\" , self . ref : getValue ()) end Info Ref objects have a deprecated field called current that is always equal to the result of getValue . Assigning to the current field is not allowed. The field will be removed in a future release. Alternatively, you can assign it to a function instead: Roact . createElement ( \"Frame\" , { -- The provided function will be called whenever the rendered instance changes. [ Roact . Ref ] = function ( rbx ) print ( \"Roblox Instance\" , rbx ) end , }) Warning When Roact.Ref is given a function, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact updates that prop! Warning When Roact.Ref is given a function, it will be called with nil when the component instance is destroyed! See the refs guide for more details.","title":"Roact.Ref"},{"location":"api-reference/#roactevent","text":"Index into Roact.Event to receive a key that can be used to connect to events when creating host elements: Roact . createElement ( \"ImageButton\" , { [ Roact . Event . MouseButton1Click ] = function ( rbx , x , y ) print ( rbx , \"clicked at position\" , x , y ) end , }) Info Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event. Warning When connecting to the Changed event, be careful not to call setState or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown! See the events guide for more details.","title":"Roact.Event"},{"location":"api-reference/#roactchange","text":"Index into Roact.Change to receive a key that can be used to connect to GetPropertyChangedSignal events. It's similar to Roact.Event : Roact . createElement ( \"ScrollingFrame\" , { [ Roact . Change . CanvasPosition ] = function ( rbx ) print ( \"ScrollingFrame scrolled to\" , rbx . CanvasPosition ) end , }) Warning Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!","title":"Roact.Change"},{"location":"api-reference/#roactnone","text":"Roact.None is a special value that can be used to clear elements from your component state when calling setState or returning from getDerivedStateFromProps . In Lua tables, removing a field from state is not possible by setting its value to nil because nil values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to Roact.None when calling setState , which will ensure that the resulting state no longer contains it: function MyComponent : didMount () self : setState ({ fieldToRemove = Roact . None }) end","title":"Roact.None"},{"location":"api-reference/#component-types","text":"","title":"Component Types"},{"location":"api-reference/#roactcomponent","text":"The base component instance that can be extended to make stateful components. Call Roact.Component:extend(\"ComponentName\") to make a new stateful component with a given name.","title":"Roact.Component"},{"location":"api-reference/#roactpurecomponent","text":"An extension of Roact.Component that only re-renders if its props or state change. PureComponent implements the shouldUpdate lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux. PureComponent is not always faster, but can often result in significant performance improvements when used correctly.","title":"Roact.PureComponent"},{"location":"api-reference/#roactportal","text":"A component that represents a portal to a Roblox Instance. Portals are created using Roact.createElement . Any children of a portal are put inside the Roblox Instance specified by the required target prop. That Roblox Instance should not be one created by Roact. Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once. See the Portals guide for a small tutorial and more details about portals.","title":"Roact.Portal"},{"location":"api-reference/#component-api","text":"","title":"Component API"},{"location":"api-reference/#defaultprops","text":"static defaultProps: Dictionary<any, any> If defaultProps is defined on a stateful component, any props that aren't specified when a component is created will be taken from there.","title":"defaultProps"},{"location":"api-reference/#init","text":"init(initialProps) -> void init is called exactly once when a new instance of a component is created. It can be used to set up the initial state , as well as any non- render related values directly on the component. Use setState inside of init to set up your initial component state: function MyComponent : init () self : setState ({ position = 0 , velocity = 10 }) end In older versions of Roact, setState was disallowed in init , and you would instead assign to state directly. It's simpler to use setState , but assigning directly to state is still acceptable inside init : function MyComponent : init () self . state = { position = 0 , velocity = 10 } end","title":"init"},{"location":"api-reference/#render","text":"render() -> Element | nil render describes what a component should display at the current instant in time. Info Roact assumes that render act likes a pure function: the result of render must depend only on props and state , and it must not have side-effects. function MyComponent : render () -- This is okay: return Roact . createElement ( \"TextLabel\" , { Text = self . props . text , Position = self . state . position }) -- Ack! Depending on values outside props/state is not allowed! return Roact . createElement ( \"TextLabel\" , { Text = self . someText , Position = getMousePosition (), }) end render must be defined for all components. The default implementation of render throws an error; if your component does not render anything, define a render function that returns nil explicitly. This helps make sure that you don't forget to define render ! function MyComponent : render () return nil end","title":"render"},{"location":"api-reference/#setstate","text":"setState(stateUpdater | stateChange) -> void setState requests an update to the component's state. Roact may schedule this update for a later time or resolve it immediately. If a function is passed to setState , that function will be called with the current state and props as arguments: function MyComponent : didMount () self : setState ( function ( prevState , props ) return { counter = prevState . counter + 1 } end ) end If this function returns nil , Roact will not schedule a re-render and no state will be updated. If a table is passed to setState , the values in that table will be merged onto the existing state: function MyComponent : didMount () self : setState ({ foo = \"bar\" }) end Setting a field in the state to Roact.None will clear it from the state. This is the only way to remove a field from a component's state! Warning setState can be called from anywhere except : Lifecycle hooks: willUnmount , willUpdate Pure functions: render , shouldUpdate Calling setState inside of init has special behavior. The result of setState will be used to determine initial state, and no additional updates will be scheduled. Roact may support calling setState in currently-disallowed places in the future. Warning setState does not always resolve synchronously! Roact may batch and reschedule state updates in order to reduce the number of total renders. When depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur! This behavior will be similar to the future behavior of React 17. See: RFClarification: why is setState asynchronous? Does React keep the order for state updates?","title":"setState"},{"location":"api-reference/#shouldupdate","text":"shouldUpdate(nextProps, nextState) -> bool shouldUpdate provides a way to override Roact's rerendering heuristics. By default, components are re-rendered any time a parent component updates, or when state is updated via setState . PureComponent implements shouldUpdate to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, all components may implement this check by default.","title":"shouldUpdate"},{"location":"api-reference/#validateprops","text":"Added in Roact 1.0.0 static validateProps(props) -> (false, message: string) | true validateProps is an optional method that can be implemented for a component. It provides a mechanism for verifying inputs passed into the component. Every time props are updated, validateProps will be called with the new props before proceeding to shouldUpdate or init . It should return the same parameters that assert expects: a boolean, true if the props passed validation, false if they did not, plus a message explaining why they failed. If the first return value is true, the second value is ignored. For performance reasons, property validation is disabled by default. To use this feature, enable propValidation via setGlobalConfig : Roact.setGlobalConfig({ propValidation = true }) See setGlobalConfig for more details. Note validateProps is a static lifecycle method. It does not have access to self , and must be a pure function. Warning Depending on the implementation, validateProps can impact performance. Recommended practice is to enable prop validation during development and leave it off in production environments.","title":"validateProps"},{"location":"api-reference/#getelementtraceback","text":"getElementTraceback() -> string | nil getElementTraceback gets the stack trace that the component was created in. This allows you to report error messages accurately.","title":"getElementTraceback"},{"location":"api-reference/#lifecycle-methods","text":"In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.","title":"Lifecycle Methods"},{"location":"api-reference/#didmount","text":"didMount() -> void didMount is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting. didMount is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.","title":"didMount"},{"location":"api-reference/#willunmount","text":"willUnmount() -> void willUnmount is fired right before Roact begins unmounting a component instance's children. willUnmount acts like a component's destructor, and is a good place to disconnect any manually-connected events.","title":"willUnmount"},{"location":"api-reference/#willupdate","text":"willUpdate(nextProps, nextState) -> void willUpdate is fired after an update is started but before a component's state and props are updated.","title":"willUpdate"},{"location":"api-reference/#didupdate","text":"didUpdate(previousProps, previousState) -> void didUpdate is fired after at the end of an update. At this point, Roact has updated the properties of any Roblox Instances and the component instance's props and state are up to date. didUpdate is a good place to send network requests or dispatch Rodux actions, but make sure to compare self.props and self.state with previousProps and previousState to avoid triggering too many updates.","title":"didUpdate"},{"location":"api-reference/#getderivedstatefromprops","text":"static getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice Used to recalculate any state that depends on being synchronized with props . Generally, you should use didUpdate to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead. getDerivedStateFromProps should return a table that contains the part of the state that should be updated. function MyComponent . getDerivedStateFromProps ( nextProps , lastState ) return { someValue = nextProps . someValue } end As with setState , you can set use the constant Roact.None to remove a field from the state. Note getDerivedStateFromProps is a static lifecycle method. It does not have access to self , and must be a pure function. Caution getDerivedStateFromProps runs before shouldUpdate and any non-nil return will cause the state table to no longer be shallow-equal. This means that a PureComponent will rerender even if nothing actually changed. Similarly, any component implementing both getDerivedStateFromProps and shouldUpdate needs to do so in a way that takes this in to account.","title":"getDerivedStateFromProps"},{"location":"advanced/bindings-and-refs/","text":"In certain situations, Roact's reconciliation process is ill-suited for managing some Instance properties. For cases like this, Roact provides escape hatches in the form of Bindings and Refs. Bindings and Refs are intended to be used in cases where Roact cannot solve a problem directly, or its solution might not be performant enough, like: Invoking functions on Roblox Instances Dynamically resizing a host component to fit its contents Gamepad selection Animations Bindings \u00b6 Bindings are special objects that Roact automatically unwraps into values. When a binding is updated, Roact will change only the specific properties that are subscribed to it. Binding Properties \u00b6 Bindings can be used to provide an external source for a prop value, or to update those values outside of the Roact reconciliation process. First, create a binding and an updater using Roact.createBinding() and put the results somewhere persistent. createBinding returns two results: a binding object and an updater function, which is used to update the binding's value. local Foo = Roact . Component : extend ( \"Foo\" ) function Foo : init () -- createBinding takes an initial value; for our purposes, 0 is fine self . clickCount , self . updateClickCount = Roact . createBinding ( 0 ) end Then, connect the binding value to something that we're rendering and the updater to something that will invoke it. function Foo : render () return Roact . createElement ( \"TextButton\" , { -- Roact unwraps the binding, sets the Text property to the binding's value, -- and subscribes to the binding Text = self . clickCount , [ Roact . Event . Activated ] = function () -- When the user clicks the button, the count will be incremented and -- Roact will update any properties that are subscribed to the binding self . updateClickCount ( self . clickCount : getValue () + 1 ) end }) end The result of this example is a TextButton that displays the number of times it's been clicked. In this case, we connect the updater to the button's Activated event. Other use cases could be connecting it to some external property in didMount or passing it to a child component as a callback. Mapped Bindings \u00b6 Often, a binding's value isn't useful by itself. It needs to be transformed into some other value in order to be useful when assigned to an Instance property. Let's modify the above component to make use of a mapped binding: function Foo : render () return Roact . createElement ( \"TextButton\" , { -- Roact will receive the mapped value from the binding Text = self . clickCount : map ( function ( value ) return \"Clicks: \" .. tostring ( value ) end ), [ Roact . Event . Activated ] = function () -- When the user clicks the button, the count will be incremented self . updateClickCount ( self . clickCount : getValue () + 1 ) end }) end Our mapped binding transforms the number of clicks into a string. Now the TextButton will display \"Clicks: 0\" instead of just the number! Refs \u00b6 While bindings are most helpful for individual props, we often want to access an entire Roblox Instance and its methods. Refs are a special type of binding that point to Roblox Instance objects that are created by Roact. Refs can only be attached to host components. This is different from React, where refs can be used to call members of composite components. Refs in Action \u00b6 To use a ref, call Roact.createRef() and put the result somewhere persistent. Generally, that means that refs are only used inside stateful components. local Foo = Roact . Component : extend ( \"Foo\" ) function Foo : init () self . textBoxRef = Roact . createRef () end Next, use the ref inside of render by creating a host component. Refs use the special key Roact.Ref . function Foo : render () return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = self . textBoxRef , }) end Finally, we can use the value of the ref at any point after our component is mounted. function Foo : didMount () -- The actual Instance can be retrieved using the `getValue` method local textBox = self . textBoxRef : getValue () print ( \"TextBox has this text:\" , textBox . Text ) end Refs as Host Properties \u00b6 In addition to providing access to underlying Roblox objects, refs also provide a handy shortcut for Roblox Instance properties that expect another Instance as their value. One commonly-encountered example is NextSelectionLeft and its counterparts. Roact's Roblox renderer knows that bindings are not valid Roblox Instance values, so it will unwrap them for you: local Bar = Roact . Component : extend ( \"Bar\" ) function Bar : init () self . leftButtonRef = Roact . createRef () self . rightButtonRef = Roact . createRef () end function Bar : render () return Roact . createElement ( \"Frame\" , nil , { LeftButton = Roact . createElement ( \"TextButton\" , { [ Roact . Ref ] = self . leftButtonRef , NextSelectionRight = self . rightButtonRef , }), RightButton = Roact . createElement ( \"TextButton\" , { [ Roact . Ref ] = self . rightButtonRef , NextSelectionLeft = self . leftButtonRef , }) }) end Since refs use bindings under the hood, they will be automatically updated whenever the ref changes. This means there's no need to worry about the order in which refs are assigned relative to when properties that use them get set. Ref Forwarding \u00b6 In Roact 1.x, refs can only be applied to host components, not stateful or function components. However, stateful or function components may accept a ref in order to pass it along to an underlying host component. In order to implement this, we wrap the given component with Roact.forwardRef . Suppose we have a styled TextBox component that still needs to accept a ref, so that users of the component can trigger functionality like TextBox:CaptureFocus() : local function FancyTextBox ( props ) return Roact . createElement ( \"TextBox\" , { Multiline = true , PlaceholderText = \"Enter your text here\" , PlaceholderColor3 = Color3 . new ( 0.4 , 0.4 , 0.4 ), [ Roact . Change . Text ] = props . onTextChange , }) end If we were to create an element using the above component, we'd be unable to get a ref to point to the underlying \"TextBox\" Instance: local Form = Roact . Component : extend ( \"Form\" ) function Form : init () self . textBoxRef = Roact . createRef () end function Form : render () return Roact . createElement ( FancyTextBox , { onTextChange = function ( value ) print ( \"text value updated to:\" , value ) end -- This doesn't actually get assigned to the underlying TextBox! [ Roact . Ref ] = self . textBoxRef , }) end function Form : didMount () -- Since self.textBoxRef never gets assigned to a host component, this -- doesn't work, and in fact will be an attempt to access a nil reference! self . textBoxRef . current : CaptureFocus () end In this instance, FancyTextBox simply doesn't do anything with the ref passed into it. However, we can easily update it using forwardRef: local FancyTextBox = Roact . forwardRef ( function ( props , ref ) return Roact . createElement ( \"TextBox\" , { Multiline = true , PlaceholderText = \"Enter your text here\" , PlaceholderColor3 = Color3 . new ( 0.4 , 0.4 , 0.4 ), [ Roact . Change . Text ] = props . onTextChange , [ Roact . Ref ] = ref , }) end ) With the above change, FancyTextBox now accepts a ref and assigns it to the \"TextBox\" host component that it renders under the hood. Our Form implementation will successfully capture focus on didMount . Function Refs \u00b6 The original ref API was based on functions instead of objects (and does not use bindings). Its use is not recommended for most cases anymore. This style of ref involves passing a function as the Roact.Ref prop as opposed to a dedicated ref object: local function Baz ( props ) return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = function ( instance ) -- Be careful to guard against nil refs; this is a gotcha of -- function refs. if instance ~= nil then print ( \"TextBox has this text:\" , instance . Text ) else print ( \"TextBox ref removed.\" ) end end , }) end Warning Function refs, unlike bindings, cannot be used as properties for host components. This will result in an error. Warning When a function ref is called, it's not guaranteed that its sibling or parent components have finished mounting. Causing side effects here can cause difficult-to-trace bugs. Warning When a component with a function ref unmounts, or when the ref value changes, the component's ref is passed nil .","title":"Bindings and Refs"},{"location":"advanced/bindings-and-refs/#bindings","text":"Bindings are special objects that Roact automatically unwraps into values. When a binding is updated, Roact will change only the specific properties that are subscribed to it.","title":"Bindings"},{"location":"advanced/bindings-and-refs/#binding-properties","text":"Bindings can be used to provide an external source for a prop value, or to update those values outside of the Roact reconciliation process. First, create a binding and an updater using Roact.createBinding() and put the results somewhere persistent. createBinding returns two results: a binding object and an updater function, which is used to update the binding's value. local Foo = Roact . Component : extend ( \"Foo\" ) function Foo : init () -- createBinding takes an initial value; for our purposes, 0 is fine self . clickCount , self . updateClickCount = Roact . createBinding ( 0 ) end Then, connect the binding value to something that we're rendering and the updater to something that will invoke it. function Foo : render () return Roact . createElement ( \"TextButton\" , { -- Roact unwraps the binding, sets the Text property to the binding's value, -- and subscribes to the binding Text = self . clickCount , [ Roact . Event . Activated ] = function () -- When the user clicks the button, the count will be incremented and -- Roact will update any properties that are subscribed to the binding self . updateClickCount ( self . clickCount : getValue () + 1 ) end }) end The result of this example is a TextButton that displays the number of times it's been clicked. In this case, we connect the updater to the button's Activated event. Other use cases could be connecting it to some external property in didMount or passing it to a child component as a callback.","title":"Binding Properties"},{"location":"advanced/bindings-and-refs/#mapped-bindings","text":"Often, a binding's value isn't useful by itself. It needs to be transformed into some other value in order to be useful when assigned to an Instance property. Let's modify the above component to make use of a mapped binding: function Foo : render () return Roact . createElement ( \"TextButton\" , { -- Roact will receive the mapped value from the binding Text = self . clickCount : map ( function ( value ) return \"Clicks: \" .. tostring ( value ) end ), [ Roact . Event . Activated ] = function () -- When the user clicks the button, the count will be incremented self . updateClickCount ( self . clickCount : getValue () + 1 ) end }) end Our mapped binding transforms the number of clicks into a string. Now the TextButton will display \"Clicks: 0\" instead of just the number!","title":"Mapped Bindings"},{"location":"advanced/bindings-and-refs/#refs","text":"While bindings are most helpful for individual props, we often want to access an entire Roblox Instance and its methods. Refs are a special type of binding that point to Roblox Instance objects that are created by Roact. Refs can only be attached to host components. This is different from React, where refs can be used to call members of composite components.","title":"Refs"},{"location":"advanced/bindings-and-refs/#refs-in-action","text":"To use a ref, call Roact.createRef() and put the result somewhere persistent. Generally, that means that refs are only used inside stateful components. local Foo = Roact . Component : extend ( \"Foo\" ) function Foo : init () self . textBoxRef = Roact . createRef () end Next, use the ref inside of render by creating a host component. Refs use the special key Roact.Ref . function Foo : render () return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = self . textBoxRef , }) end Finally, we can use the value of the ref at any point after our component is mounted. function Foo : didMount () -- The actual Instance can be retrieved using the `getValue` method local textBox = self . textBoxRef : getValue () print ( \"TextBox has this text:\" , textBox . Text ) end","title":"Refs in Action"},{"location":"advanced/bindings-and-refs/#refs-as-host-properties","text":"In addition to providing access to underlying Roblox objects, refs also provide a handy shortcut for Roblox Instance properties that expect another Instance as their value. One commonly-encountered example is NextSelectionLeft and its counterparts. Roact's Roblox renderer knows that bindings are not valid Roblox Instance values, so it will unwrap them for you: local Bar = Roact . Component : extend ( \"Bar\" ) function Bar : init () self . leftButtonRef = Roact . createRef () self . rightButtonRef = Roact . createRef () end function Bar : render () return Roact . createElement ( \"Frame\" , nil , { LeftButton = Roact . createElement ( \"TextButton\" , { [ Roact . Ref ] = self . leftButtonRef , NextSelectionRight = self . rightButtonRef , }), RightButton = Roact . createElement ( \"TextButton\" , { [ Roact . Ref ] = self . rightButtonRef , NextSelectionLeft = self . leftButtonRef , }) }) end Since refs use bindings under the hood, they will be automatically updated whenever the ref changes. This means there's no need to worry about the order in which refs are assigned relative to when properties that use them get set.","title":"Refs as Host Properties"},{"location":"advanced/bindings-and-refs/#ref-forwarding","text":"In Roact 1.x, refs can only be applied to host components, not stateful or function components. However, stateful or function components may accept a ref in order to pass it along to an underlying host component. In order to implement this, we wrap the given component with Roact.forwardRef . Suppose we have a styled TextBox component that still needs to accept a ref, so that users of the component can trigger functionality like TextBox:CaptureFocus() : local function FancyTextBox ( props ) return Roact . createElement ( \"TextBox\" , { Multiline = true , PlaceholderText = \"Enter your text here\" , PlaceholderColor3 = Color3 . new ( 0.4 , 0.4 , 0.4 ), [ Roact . Change . Text ] = props . onTextChange , }) end If we were to create an element using the above component, we'd be unable to get a ref to point to the underlying \"TextBox\" Instance: local Form = Roact . Component : extend ( \"Form\" ) function Form : init () self . textBoxRef = Roact . createRef () end function Form : render () return Roact . createElement ( FancyTextBox , { onTextChange = function ( value ) print ( \"text value updated to:\" , value ) end -- This doesn't actually get assigned to the underlying TextBox! [ Roact . Ref ] = self . textBoxRef , }) end function Form : didMount () -- Since self.textBoxRef never gets assigned to a host component, this -- doesn't work, and in fact will be an attempt to access a nil reference! self . textBoxRef . current : CaptureFocus () end In this instance, FancyTextBox simply doesn't do anything with the ref passed into it. However, we can easily update it using forwardRef: local FancyTextBox = Roact . forwardRef ( function ( props , ref ) return Roact . createElement ( \"TextBox\" , { Multiline = true , PlaceholderText = \"Enter your text here\" , PlaceholderColor3 = Color3 . new ( 0.4 , 0.4 , 0.4 ), [ Roact . Change . Text ] = props . onTextChange , [ Roact . Ref ] = ref , }) end ) With the above change, FancyTextBox now accepts a ref and assigns it to the \"TextBox\" host component that it renders under the hood. Our Form implementation will successfully capture focus on didMount .","title":"Ref Forwarding"},{"location":"advanced/bindings-and-refs/#function-refs","text":"The original ref API was based on functions instead of objects (and does not use bindings). Its use is not recommended for most cases anymore. This style of ref involves passing a function as the Roact.Ref prop as opposed to a dedicated ref object: local function Baz ( props ) return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = function ( instance ) -- Be careful to guard against nil refs; this is a gotcha of -- function refs. if instance ~= nil then print ( \"TextBox has this text:\" , instance . Text ) else print ( \"TextBox ref removed.\" ) end end , }) end Warning Function refs, unlike bindings, cannot be used as properties for host components. This will result in an error. Warning When a function ref is called, it's not guaranteed that its sibling or parent components have finished mounting. Causing side effects here can cause difficult-to-trace bugs. Warning When a component with a function ref unmounts, or when the ref value changes, the component's ref is passed nil .","title":"Function Refs"},{"location":"advanced/context/","text":"Added in Roact 1.3.0 Basic Usage Roact supports a feature called context which enables passing values down the tree without having to pass them through props. Roact's Context API is based on React's Context API . Context is commonly used to implement features like dependency injection, dynamic theming, and scoped state storage. Basic Usage \u00b6 local ThemeContext = Roact . createContext ( defaultValue ) Context objects contain two components, Consumer and Provider . The Consumer component accepts a render function as its only prop, which is used to render its children. It's passed one argument, which is the context value from the nearest matching Provider ancestor. If there is no Provider ancestor, then defaultValue will be passed instead. local function ThemedButton ( props ) return Roact . createElement ( ThemeContext . Consumer , { render = function ( theme ) return Roact . createElement ( \"TextButton\" , { Size = UDim2 . new ( 0 , 100 , 0 , 100 ), Text = \"Click Me!\" , TextColor3 = theme . foreground , BackgroundColor3 = theme . background , }) end }) end The Provider component accepts a value prop as well as children. Any of its descendants will have access to the value provided to it by using the Consumer component like above. Whenever the Provider receives a new value prop in an update, any attached Consumer components will re-render with the new value. This value could be externally controlled, or could be controlled by state in a component wrapping Provider : local ThemeController = Roact . Component : extend ( \"ThemeController\" ) function ThemeController : init () self : setState ({ theme = { foreground = Color3 . new ( 1 , 1 , 1 ), background = Color3 . new ( 0 , 0 , 0 ), } }) end function ThemeController : render () return Roact . createElement ( ThemeContext . Provider , { value = self . state . theme , }, self . props [ Roact . Children ]) end Danger Legacy Context is a deprecated feature that will be removed in a future release of Roact. Roact also has a deprecated version of context that pre-dates the stable context API. Legacy context values do not update dynamically on their own. It is up to the context user to create their own mechanism for updates, probably using a wrapper component and setState . To use it, add new entries to self._context in Component:init() to create a provider: local Provider = Roact . Component : extend ( \"FooProvider\" ) -- Using a unique non-string key is recommended to avoid collisions. local FooKey = {} function Provider : init () self . _context [ FooKey ] = { value = 5 , } end ...and read from that same value in Component:init() in your consumer component: local Consumer = Roact . Component : extend ( \"FooConsumer\" ) function Consumer : init () self . foo = self . _context [ FooKey ] end function Consumer : render () return Roact . createElement ( \"TextLabel\" , { Text = \"Foo: \" .. self . foo . value , }) end","title":"Context"},{"location":"advanced/context/#basic-usage","text":"local ThemeContext = Roact . createContext ( defaultValue ) Context objects contain two components, Consumer and Provider . The Consumer component accepts a render function as its only prop, which is used to render its children. It's passed one argument, which is the context value from the nearest matching Provider ancestor. If there is no Provider ancestor, then defaultValue will be passed instead. local function ThemedButton ( props ) return Roact . createElement ( ThemeContext . Consumer , { render = function ( theme ) return Roact . createElement ( \"TextButton\" , { Size = UDim2 . new ( 0 , 100 , 0 , 100 ), Text = \"Click Me!\" , TextColor3 = theme . foreground , BackgroundColor3 = theme . background , }) end }) end The Provider component accepts a value prop as well as children. Any of its descendants will have access to the value provided to it by using the Consumer component like above. Whenever the Provider receives a new value prop in an update, any attached Consumer components will re-render with the new value. This value could be externally controlled, or could be controlled by state in a component wrapping Provider : local ThemeController = Roact . Component : extend ( \"ThemeController\" ) function ThemeController : init () self : setState ({ theme = { foreground = Color3 . new ( 1 , 1 , 1 ), background = Color3 . new ( 0 , 0 , 0 ), } }) end function ThemeController : render () return Roact . createElement ( ThemeContext . Provider , { value = self . state . theme , }, self . props [ Roact . Children ]) end Danger Legacy Context is a deprecated feature that will be removed in a future release of Roact. Roact also has a deprecated version of context that pre-dates the stable context API. Legacy context values do not update dynamically on their own. It is up to the context user to create their own mechanism for updates, probably using a wrapper component and setState . To use it, add new entries to self._context in Component:init() to create a provider: local Provider = Roact . Component : extend ( \"FooProvider\" ) -- Using a unique non-string key is recommended to avoid collisions. local FooKey = {} function Provider : init () self . _context [ FooKey ] = { value = 5 , } end ...and read from that same value in Component:init() in your consumer component: local Consumer = Roact . Component : extend ( \"FooConsumer\" ) function Consumer : init () self . foo = self . _context [ FooKey ] end function Consumer : render () return Roact . createElement ( \"TextLabel\" , { Text = \"Foo: \" .. self . foo . value , }) end","title":"Basic Usage"},{"location":"advanced/fragments/","text":"Fragments are a tool for avoiding unnecessary nesting when organizing components by allowing components to render collections of elements without wrapping them in a single containing element. Without Fragments \u00b6 Typically, Roact components will render a single element via createElement . For example, suppose we define a component like this: local function TeamList ( props ) return Roact . createElement ( \"Frame\" , { -- Props for Frame... }, { Layout = Roact . createElement ( \"UIListLayout\" , { -- Props for UIListLayout... }) ListItems = Roact . createElement ( TeamLabels ) }) end Suppose we also want to use a separate component to render a collection of TextLabel s: local function TeamLabels ( props ) return Roact . createElement ( \"Frame\" , { -- Props for Frame... }, { RedTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }), BlueTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }) }) end Unfortunately, the TeamLabels component can't return two different labels without wrapping them in a containing frame. The resulting Roblox hierarchy from these TeamList component won't actually apply the UIListLayout to the list of items, because it's grouped incorrectly: Frame: UIListLayout Frame: TextLabel TextLabel With Fragments \u00b6 In order to separate our list contents from our list container, we need to be able to return a group of elements from our render method rather than a single one. Fragments make this possible: local function TeamLabels ( props ) return Roact . createFragment ({ RedTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }), BlueTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }) }) end We provide Roact.createFragment with a table of elements. These elements will result in multiple children of this component's parent. When used in combination with the above TeamList component, it will generate the desired Roblox hierarchy: Frame: UIListLayout TextLabel TextLabel We are also free to create alternate views that use the same TeamLabels component with different Layouts or groupings.","title":"Fragments"},{"location":"advanced/fragments/#without-fragments","text":"Typically, Roact components will render a single element via createElement . For example, suppose we define a component like this: local function TeamList ( props ) return Roact . createElement ( \"Frame\" , { -- Props for Frame... }, { Layout = Roact . createElement ( \"UIListLayout\" , { -- Props for UIListLayout... }) ListItems = Roact . createElement ( TeamLabels ) }) end Suppose we also want to use a separate component to render a collection of TextLabel s: local function TeamLabels ( props ) return Roact . createElement ( \"Frame\" , { -- Props for Frame... }, { RedTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }), BlueTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }) }) end Unfortunately, the TeamLabels component can't return two different labels without wrapping them in a containing frame. The resulting Roblox hierarchy from these TeamList component won't actually apply the UIListLayout to the list of items, because it's grouped incorrectly: Frame: UIListLayout Frame: TextLabel TextLabel","title":"Without Fragments"},{"location":"advanced/fragments/#with-fragments","text":"In order to separate our list contents from our list container, we need to be able to return a group of elements from our render method rather than a single one. Fragments make this possible: local function TeamLabels ( props ) return Roact . createFragment ({ RedTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }), BlueTeam = Roact . createElement ( \"TextLabel\" , { -- Props for item... }) }) end We provide Roact.createFragment with a table of elements. These elements will result in multiple children of this component's parent. When used in combination with the above TeamList component, it will generate the desired Roblox hierarchy: Frame: UIListLayout TextLabel TextLabel We are also free to create alternate views that use the same TeamLabels component with different Layouts or groupings.","title":"With Fragments"},{"location":"advanced/portals/","text":"Portals are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance. Info Eventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game, Portal . To create a portal, use the Roact.Portal component with createElement : local function PartInWorkspace ( props ) return Roact . createElement ( Roact . Portal , { target = Workspace }, { SomePart = Roact . createElement ( \"Part\" , { Anchored = true }) }) end When we create PartInWorkspace , even if it's deep into our Roact tree, a Part Instance named SomePart will be created in Workspace . Warning Portals should only be created to objects that aren't managed by Roact! One particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them! local PlayerGui = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui -- Our Modal component is a standard component, but with a portal at the top! local function Modal ( props ) return Roact . createElement ( Roact . Portal , { target = PlayerGui }, { Modal = Roact . createElement ( \"ScreenGui\" , {}, { Label = Roact . createElement ( \"TextButton\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Click me to close!\" , [ Roact . Event . Activated ] = function () props . onClose () end }) }) }) end -- A ModalButton contains a little bit of state to decide whether the dialog -- should be open or not. local ModalButton = Roact . Component : extend ( \"ModalButton\" ) function ModalButton : init () self . state = { dialogOpen = false } end function ModalButton : render () local dialog = nil -- If the dialog isn't open, just avoid rendering it. if self . state . dialogOpen then dialog = Roact . createElement ( Modal , { onClose = function () self : setState ({ dialogOpen = false }) end }) end return Roact . createElement ( \"TextButton\" , { Size = UDim2 . new ( 0 , 400 , 0 , 300 ), Text = \"Click me to open modal dialog!\" , [ Roact . Event . Activated ] = function () self : setState ({ dialogOpen = true }) end }, { -- If `dialog` ends up nil, this line does nothing! Dialog = dialog }) end","title":"Portals"},{"location":"guide/components/","text":"Components are encapsulated, reusable pieces of UI that you can combine to build a complete UI. Components accept inputs, known as props , and return elements to describe the UI that should represent those inputs. Types of Components \u00b6 Host Components \u00b6 A host component is nothing more than a string that matches the name of a Roblox class. We used these in our earlier discussion about elements as the first argument to createElement . Examples include \"Frame\" , \"ImageButton\" , etc. When our component is a host component, the props that we pass to it will be turned directly into properties on the Roblox instance that the component refers to. Function Components \u00b6 Function components are the simplest kind of user-defined component: they're just functions that accept props as their only argument, and return some elements. local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end Stateful Components \u00b6 Roact also has stateful components, which provide additional features like lifecycle methods and state. We'll talk about these features in a later section. You can create a stateful component by calling Roact.Component:extend and passing in the component's name. local Greeting = Roact . Component : extend ( \"Greeting\" ) function Greeting : render () return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. self . props . name }) end Using Components \u00b6 In our previous examples, we passed strings to Roact.createElement to create elements that represented Roblox Instances. We can also pass our custom components to create elements that represent them: local hello = Roact . createElement ( Greeting , { name = \"Rick James\" }) The name value is passed to our component as props, which we can reference as the props argument in our function component or self.props in our stateful component. Components in Components \u00b6 Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components! local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end local function GreetEveryone () return Roact . createElement ( \"ScreenGui\" , {}, { Layout = Roact . createElement ( \"UIListLayout\" ), HelloJoe = Roact . createElement ( Greeting , { name = \"Joe\" }), HelloMary = Roact . createElement ( Greeting , { name = \"Mary\" }) }) end Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children. Incrementing Counter, Part Two \u00b6 We can revisit the incrementing counter example from the previous section, now using a function component. Changed sections are highlighted. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a function component that represents our UI local function Clock ( props ) local currentTime = props . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local clockElement = Roact . createElement ( Clock , { currentTime = currentTime }) local handle = Roact . mount ( clockElement , PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . update ( handle , Roact . createElement ( Clock , { currentTime = currentTime })) end","title":"Components"},{"location":"guide/components/#types-of-components","text":"","title":"Types of Components"},{"location":"guide/components/#host-components","text":"A host component is nothing more than a string that matches the name of a Roblox class. We used these in our earlier discussion about elements as the first argument to createElement . Examples include \"Frame\" , \"ImageButton\" , etc. When our component is a host component, the props that we pass to it will be turned directly into properties on the Roblox instance that the component refers to.","title":"Host Components"},{"location":"guide/components/#function-components","text":"Function components are the simplest kind of user-defined component: they're just functions that accept props as their only argument, and return some elements. local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end","title":"Function Components"},{"location":"guide/components/#stateful-components","text":"Roact also has stateful components, which provide additional features like lifecycle methods and state. We'll talk about these features in a later section. You can create a stateful component by calling Roact.Component:extend and passing in the component's name. local Greeting = Roact . Component : extend ( \"Greeting\" ) function Greeting : render () return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. self . props . name }) end","title":"Stateful Components"},{"location":"guide/components/#using-components","text":"In our previous examples, we passed strings to Roact.createElement to create elements that represented Roblox Instances. We can also pass our custom components to create elements that represent them: local hello = Roact . createElement ( Greeting , { name = \"Rick James\" }) The name value is passed to our component as props, which we can reference as the props argument in our function component or self.props in our stateful component.","title":"Using Components"},{"location":"guide/components/#components-in-components","text":"Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components! local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end local function GreetEveryone () return Roact . createElement ( \"ScreenGui\" , {}, { Layout = Roact . createElement ( \"UIListLayout\" ), HelloJoe = Roact . createElement ( Greeting , { name = \"Joe\" }), HelloMary = Roact . createElement ( Greeting , { name = \"Mary\" }) }) end Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children.","title":"Components in Components"},{"location":"guide/components/#incrementing-counter-part-two","text":"We can revisit the incrementing counter example from the previous section, now using a function component. Changed sections are highlighted. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a function component that represents our UI local function Clock ( props ) local currentTime = props . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local clockElement = Roact . createElement ( Clock , { currentTime = currentTime }) local handle = Roact . mount ( clockElement , PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . update ( handle , Roact . createElement ( Clock , { currentTime = currentTime })) end","title":"Incrementing Counter, Part Two"},{"location":"guide/elements/","text":"Like React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI. Elements describe what you want your UI to look like at a single point in time. They're immutable : you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal. You can create an element using Roact.createElement . You will need to pass it a Roblox class name as the first argument (this is a kind of component, which we discuss in the next section ), and any properties as the second argument! local myElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 50 , 0 , 50 ) }) You can also represent children by passing them to the optional third argument of createElement : local myElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 50 , 0 , 50 ) }, { SomeChild = Roact . createElement ( \"TextLabel\" , { Text = \"Hello, Roact!\" }) }) Creating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call Roact.mount : -- Create a new Frame object in 'Workspace' local myHandle = Roact . mount ( myElement , game . Workspace ) Mounting is the process of creating a Roact component instance as well as any associated Roblox Instances. Roact.mount returns a handle that we can later use to update or destroy that object with Roact.update and Roact.unmount . Changing What's Rendered \u00b6 In order to change the UI that we've created, we need to create a new set of elements and update the existing tree to match it. Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time. Using myHandle from above, we can update the size and text of our label: -- Make some new elements that describe what our new UI will look like. local myNewElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 100 , 0 , 50 ) }, { SomeChild = Roact . createElement ( \"TextLabel\" , { Text = \"Hello, again, Roact!\" }) }) -- Update our hierarchy to match those elements. myHandle = Roact . update ( myHandle , myNewElement ) Info Most projects using UI don't use Roact.update and instead change UI using state and lifecycle events, which will be introduced in the next section. Roact.update is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact! Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances. Unmounting the Tree \u00b6 Roact provides a method called Roact.unmount that we can use when we're finished with our tree. Roact . unmount ( myHandle ) Unmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it. Warning Trying to use a handle after it's been passed to Roact.unmount will result in errors! Incrementing Counter \u00b6 Using what's been covered so far, we can make a simple program that tells you how long it has been running. This is a complete example that should work when put into a LocalScript in StarterPlayerScripts . It assumes Roact has been installed into ReplicatedStorage . local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a function that creates the elements for our UI. -- Later, we'll use components, which are the best way to organize UI in Roact. local function clock ( currentTime ) return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local handle = Roact . mount ( clock ( currentTime ), PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . update ( handle , clock ( currentTime )) end In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.","title":"Elements"},{"location":"guide/elements/#changing-whats-rendered","text":"In order to change the UI that we've created, we need to create a new set of elements and update the existing tree to match it. Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time. Using myHandle from above, we can update the size and text of our label: -- Make some new elements that describe what our new UI will look like. local myNewElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 100 , 0 , 50 ) }, { SomeChild = Roact . createElement ( \"TextLabel\" , { Text = \"Hello, again, Roact!\" }) }) -- Update our hierarchy to match those elements. myHandle = Roact . update ( myHandle , myNewElement ) Info Most projects using UI don't use Roact.update and instead change UI using state and lifecycle events, which will be introduced in the next section. Roact.update is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact! Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.","title":"Changing What's Rendered"},{"location":"guide/elements/#unmounting-the-tree","text":"Roact provides a method called Roact.unmount that we can use when we're finished with our tree. Roact . unmount ( myHandle ) Unmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it. Warning Trying to use a handle after it's been passed to Roact.unmount will result in errors!","title":"Unmounting the Tree"},{"location":"guide/elements/#incrementing-counter","text":"Using what's been covered so far, we can make a simple program that tells you how long it has been running. This is a complete example that should work when put into a LocalScript in StarterPlayerScripts . It assumes Roact has been installed into ReplicatedStorage . local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a function that creates the elements for our UI. -- Later, we'll use components, which are the best way to organize UI in Roact. local function clock ( currentTime ) return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local handle = Roact . mount ( clock ( currentTime ), PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . update ( handle , clock ( currentTime )) end In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.","title":"Incrementing Counter"},{"location":"guide/events/","text":"Roact manages Instance event connections automatically as part of rendering. To connect to an event, pass a prop with Roact.Event.EVENT_NAME as the key and a function as the value. Roact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in. local button = Roact . createElement ( \"TextButton\" , { Text = \"Click me!\" , Size = UDim2 . new ( 0 , 400 , 0 , 300 ), [ Roact . Event . MouseButton1Click ] = function ( rbx ) print ( \"The button was clicked!\" ) end }) Info Events will automatically be disconnected when a component instance is unmounted! To listen to GetPropertyChangedSignal , Roact provides a similar API, using props like Roact.Change.PROPERTY_NAME : local frame = Roact . createElement ( \"Frame\" , { [ Roact . Change . AbsoluteSize ] = function ( rbx ) print ( \"Absolute size changed to\" , rbx . AbsoluteSize ) end }) Warning Roact can trigger events while updating the tree! If Roact triggers an event handler that calls setState synchronously, an error will be thrown. In the future, Roact may delay evaluation of event handlers to prevent them from happening while Roact is modifying the tree.","title":"Events"},{"location":"guide/hello-roact/","text":"Info These examples assumes that you've successfully installed Roact into ReplicatedStorage ! Add a new LocalScript object to StarterPlayer.StarterPlayerScripts either in Roblox Studio, or via Rojo: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) local app = Roact . createElement ( \"ScreenGui\" , {}, { HelloWorld = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 0 , 400 , 0 , 300 ), Text = \"Hello, Roact!\" }) }) Roact . mount ( app , Players . LocalPlayer . PlayerGui ) When you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!","title":"Hello, Roact!"},{"location":"guide/installation/","text":"There are two supported ways to get started with Roact. For our examples, we'll install Roact to ReplicatedStorage . In practice, it's okay to install Roact anywhere you want! Method 1: Model File (Roblox Studio) \u00b6 Download the rbxm model file attached to the latest release from the GitHub releases page . Insert the model into Studio into a place like ReplicatedStorage Method 2: Filesystem \u00b6 Copy the src directory into your codebase Rename the folder to Roact Use a plugin like Rojo to sync the files into a place","title":"Installation"},{"location":"guide/installation/#method-1-model-file-roblox-studio","text":"Download the rbxm model file attached to the latest release from the GitHub releases page . Insert the model into Studio into a place like ReplicatedStorage","title":"Method 1: Model File (Roblox Studio)"},{"location":"guide/installation/#method-2-filesystem","text":"Copy the src directory into your codebase Rename the folder to Roact Use a plugin like Rojo to sync the files into a place","title":"Method 2: Filesystem"},{"location":"guide/state-and-lifecycle/","text":"In the previous section, we talked about using components to create reusable chunks of state, and introduced host , function , and stateful components. Stateful components do everything that function components do, but have the addition of mutable state and lifecycle methods . State \u00b6 State is the term we use to talk about values that are owned by a component itself. Unlike props , which are passed to a component from above, state is created within a component and can only be updated by that component. We can set up the initial state of a stateful component inside of a method named init : function MyComponent : init () self : setState ({ currentTime = 0 }) end To update state, we use a special method named setState . setState will merge any values we give it into our state. It will overwrite any existing values, and leave any values we don't specify alone. There's another form of setState we can use. When the new state we want our component to have depends on our current state, like incrementing a value, we use this form: -- This is another special method, didMount, that we'll talk about in a moment. function MyComponent : didMount () self : setState ( function ( state ) return { currentTime = 1 + state . currentTime } end ) end In this case, we're passing a function to setState . This function is called and passed the current state, and returns a new state. It can also return nil to abort the state update, which lets Roact make some handy optimizations. Right now, this version of setState works exactly the same way as the version that accepts an object. In the future, Roact will support optimizations that make this difference more important, like asynchronous rendering . Lifecycle Methods \u00b6 Stateful components can provide methods to Roact that are called when certain things happen to a component instance. Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and produce other side-effects. The most useful lifecycle methods are generally didMount and didUpdate . Most components that do things that are difficult to express in Roact itself will use these lifecycle methods. Here's a chart of all of the methods available. You can also check out the Lifecycle Methods section of the API reference for more details. Incrementing Counter, Part Three \u00b6 Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use setState to trigger a re-render instead of Roact.update . Generally, this ticking clock demonstrates how many stateful components are structured in Roact. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) local Clock = Roact . Component : extend ( \"Clock\" ) function Clock : init () -- In init, we can use setState to set up our initial component state. self : setState ({ currentTime = 0 }) end -- This render function is almost completely unchanged from the first example. function Clock : render () -- As a convention, we'll pull currentTime out of state right away. local currentTime = self . state . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end -- Set up our loop in didMount, so that it starts running when our -- component is created. function Clock : didMount () -- Set a value that we can change later to stop our loop self . running = true -- We don't want to block the main thread, so we spawn a new one! spawn ( function () while self . running do -- Because we depend on the previous state, we use the function -- variant of setState. This will matter more when Roact gets -- asynchronous rendering! self : setState ( function ( state ) return { currentTime = state . currentTime + 1 } end ) wait ( 1 ) end end ) end -- Stop the loop in willUnmount, so that our loop terminates when the -- component is destroyed. function Clock : willUnmount () self . running = false end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our UI, which now runs on its own! local handle = Roact . mount ( Roact . createElement ( Clock ), PlayerGui , \"Clock UI\" ) -- Later, we can destroy our UI and disconnect everything correctly. wait ( 10 ) Roact . unmount ( handle )","title":"State and Lifecycle"},{"location":"guide/state-and-lifecycle/#state","text":"State is the term we use to talk about values that are owned by a component itself. Unlike props , which are passed to a component from above, state is created within a component and can only be updated by that component. We can set up the initial state of a stateful component inside of a method named init : function MyComponent : init () self : setState ({ currentTime = 0 }) end To update state, we use a special method named setState . setState will merge any values we give it into our state. It will overwrite any existing values, and leave any values we don't specify alone. There's another form of setState we can use. When the new state we want our component to have depends on our current state, like incrementing a value, we use this form: -- This is another special method, didMount, that we'll talk about in a moment. function MyComponent : didMount () self : setState ( function ( state ) return { currentTime = 1 + state . currentTime } end ) end In this case, we're passing a function to setState . This function is called and passed the current state, and returns a new state. It can also return nil to abort the state update, which lets Roact make some handy optimizations. Right now, this version of setState works exactly the same way as the version that accepts an object. In the future, Roact will support optimizations that make this difference more important, like asynchronous rendering .","title":"State"},{"location":"guide/state-and-lifecycle/#lifecycle-methods","text":"Stateful components can provide methods to Roact that are called when certain things happen to a component instance. Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and produce other side-effects. The most useful lifecycle methods are generally didMount and didUpdate . Most components that do things that are difficult to express in Roact itself will use these lifecycle methods. Here's a chart of all of the methods available. You can also check out the Lifecycle Methods section of the API reference for more details.","title":"Lifecycle Methods"},{"location":"guide/state-and-lifecycle/#incrementing-counter-part-three","text":"Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use setState to trigger a re-render instead of Roact.update . Generally, this ticking clock demonstrates how many stateful components are structured in Roact. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) local Clock = Roact . Component : extend ( \"Clock\" ) function Clock : init () -- In init, we can use setState to set up our initial component state. self : setState ({ currentTime = 0 }) end -- This render function is almost completely unchanged from the first example. function Clock : render () -- As a convention, we'll pull currentTime out of state right away. local currentTime = self . state . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end -- Set up our loop in didMount, so that it starts running when our -- component is created. function Clock : didMount () -- Set a value that we can change later to stop our loop self . running = true -- We don't want to block the main thread, so we spawn a new one! spawn ( function () while self . running do -- Because we depend on the previous state, we use the function -- variant of setState. This will matter more when Roact gets -- asynchronous rendering! self : setState ( function ( state ) return { currentTime = state . currentTime + 1 } end ) wait ( 1 ) end end ) end -- Stop the loop in willUnmount, so that our loop terminates when the -- component is destroyed. function Clock : willUnmount () self . running = false end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our UI, which now runs on its own! local handle = Roact . mount ( Roact . createElement ( Clock ), PlayerGui , \"Clock UI\" ) -- Later, we can destroy our UI and disconnect everything correctly. wait ( 10 ) Roact . unmount ( handle )","title":"Incrementing Counter, Part Three"},{"location":"performance/overview/","text":"Roact operates on the principle that it's much easier to build UI declaratively. When something changes, the UI is rebuilt virtually and then the minimal necessary changes are made to the actual UI elements. For simple projects, performance is unlikely to be an issue. But Roact is built in Lua, and Lua can be slow. The following pages provide a number of techniques and best practices that you can employ to avoid performance strain with your Roact apps.","title":"Overview"},{"location":"performance/reduce-reconciliation/","text":"In all likelihood, the primary source of performance gains for your app will come from reducing the amount of work that Roact's reconciliation process requires. This is accomplished by: Indicating to Roact that some reconciliation work can be skipped Making sure your elements only change in ways you intended shouldUpdate Lifecycle Method \u00b6 When a Roact Component's state or props change, it will call the Component's shouldUpdate method to determine whether or not to re-render it. The default implementation will always return true. function Component : shouldUpdate ( newProps , newState ) return true end If you have a more complex component that only needs to re-render in certain situations, you can either use PureComponent (discussed below) or implement your own shouldUpdate and return false in any case where an update is not required. Warning Manually implementing shouldUpdate is dangerous ! If done carelessly, it can easily create confusing or subtle bugs. In most cases, the preferable solution is to use PureComponent instead, which has a simple and robust implementation of shouldUpdate . PureComponent \u00b6 One common implementation of shouldUpdate is to do a shallow comparison between current and previous props and state. Roact provides an extension of Roact.Component called Roact.PureComponent that uses this implementation. Let's use the following example: local Item = Roact . Component : extend ( \"Item\" ) function Item : render () local icon = self . props . icon local layoutOrder = self . props . layoutOrder -- Create a list item with the item's icon and name return Roact . createElement ( \"ImageLabel\" , { LayoutOrder = layoutOrder , Image = icon , }) end local Inventory = Roact . Component : extend ( \"Inventory\" ) function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} -- Create a UIListLayout to space out our items itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Add the element to our list itemList [ i ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end In the above example, adding a new item to the items prop of the Inventory would cause all of the child Item elements to re-render, even if they haven't changed at all. This means if you add an item to an Inventory that already has 5 items, the result will be 6 renders of the Item component. Lets change Item to a PureComponent : local Item = Roact . PureComponent : extend ( \"Item\" ) Now, if we add a new item to the end of the Inventory or change something about an existing item, we'll only re-render the Inventory itself and the modified Item ! Warning When working with PureComponent , it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change. Info There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere! Stable Keys \u00b6 Another performance improvement we can make is to use stable, unique keys to refer to our child elements. When the list that we pass into the Inventory component changes, Roact updates our Roblox UI by adjusting the properties of each Roblox Instance according to the new list of elements. For example, let's suppose our list of items is as follows: { { id = \"sword\" , icon = swordIcon }, -- [1] { id = \"shield\" , icon = shieldIcon }, -- [2] } If we add a new item to the beginning, then we'll end up with a list like this: { { id = \"potion\" , icon = potionIcon } -- [1] { id = \"sword\" , icon = swordIcon }, -- [2] { id = \"shield\" , icon = shieldIcon }, -- [3] } When Roact updates the underlying ImageLabel objects, it will need to change their icons so that the item at [1] has the potion icon, the item at [2] has the sword icon, and a new ImageLabel is added at [3] with the shield icon. We'd like for Roact to know that the new item was added at [1] and that the sword and shield items simply moved down in the list. That way it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest. So let's fix it! We'll make our list of Item elements use the item's id for its keys instead of the indexes in the items list: function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Each element is now added at a stable key itemList [ item . id ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be updated. When we add the third element to the list, Roact will set the LayoutOrder property on for each ImageLabel and only set the Image property on the newly added one! Info Switching to static keys might seem insignificant for this example, but if our Item component becomes more complicated and our inventory gets bigger, it can make a significant difference!","title":"Reduce Reconciliation"},{"location":"performance/reduce-reconciliation/#shouldupdate-lifecycle-method","text":"When a Roact Component's state or props change, it will call the Component's shouldUpdate method to determine whether or not to re-render it. The default implementation will always return true. function Component : shouldUpdate ( newProps , newState ) return true end If you have a more complex component that only needs to re-render in certain situations, you can either use PureComponent (discussed below) or implement your own shouldUpdate and return false in any case where an update is not required. Warning Manually implementing shouldUpdate is dangerous ! If done carelessly, it can easily create confusing or subtle bugs. In most cases, the preferable solution is to use PureComponent instead, which has a simple and robust implementation of shouldUpdate .","title":"shouldUpdate Lifecycle Method"},{"location":"performance/reduce-reconciliation/#purecomponent","text":"One common implementation of shouldUpdate is to do a shallow comparison between current and previous props and state. Roact provides an extension of Roact.Component called Roact.PureComponent that uses this implementation. Let's use the following example: local Item = Roact . Component : extend ( \"Item\" ) function Item : render () local icon = self . props . icon local layoutOrder = self . props . layoutOrder -- Create a list item with the item's icon and name return Roact . createElement ( \"ImageLabel\" , { LayoutOrder = layoutOrder , Image = icon , }) end local Inventory = Roact . Component : extend ( \"Inventory\" ) function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} -- Create a UIListLayout to space out our items itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Add the element to our list itemList [ i ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end In the above example, adding a new item to the items prop of the Inventory would cause all of the child Item elements to re-render, even if they haven't changed at all. This means if you add an item to an Inventory that already has 5 items, the result will be 6 renders of the Item component. Lets change Item to a PureComponent : local Item = Roact . PureComponent : extend ( \"Item\" ) Now, if we add a new item to the end of the Inventory or change something about an existing item, we'll only re-render the Inventory itself and the modified Item ! Warning When working with PureComponent , it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change. Info There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!","title":"PureComponent"},{"location":"performance/reduce-reconciliation/#stable-keys","text":"Another performance improvement we can make is to use stable, unique keys to refer to our child elements. When the list that we pass into the Inventory component changes, Roact updates our Roblox UI by adjusting the properties of each Roblox Instance according to the new list of elements. For example, let's suppose our list of items is as follows: { { id = \"sword\" , icon = swordIcon }, -- [1] { id = \"shield\" , icon = shieldIcon }, -- [2] } If we add a new item to the beginning, then we'll end up with a list like this: { { id = \"potion\" , icon = potionIcon } -- [1] { id = \"sword\" , icon = swordIcon }, -- [2] { id = \"shield\" , icon = shieldIcon }, -- [3] } When Roact updates the underlying ImageLabel objects, it will need to change their icons so that the item at [1] has the potion icon, the item at [2] has the sword icon, and a new ImageLabel is added at [3] with the shield icon. We'd like for Roact to know that the new item was added at [1] and that the sword and shield items simply moved down in the list. That way it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest. So let's fix it! We'll make our list of Item elements use the item's id for its keys instead of the indexes in the items list: function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Each element is now added at a stable key itemList [ item . id ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be updated. When we add the third element to the list, Roact will set the LayoutOrder property on for each ImageLabel and only set the Image property on the newly added one! Info Switching to static keys might seem insignificant for this example, but if our Item component becomes more complicated and our inventory gets bigger, it can make a significant difference!","title":"Stable Keys"}]}